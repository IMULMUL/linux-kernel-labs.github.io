=========================
Kernel Development on ARM
=========================

Lab objectives
==============

* get a feeling of what System on a Chip (SoC) means
* get familiar with embedded world using ARM as support architecture
* understand what a Board Support Package means (BSP)
* compile and boot an ARM kernel with Qemu using i.MX6UL platform as an example
* get familiar with hardware description using Device Trees

System on a Chip
================

A System on a Chip (**SoC**) is an integrated circuit (**IC**) that integrates an entire system onto it. The components
that can be usually found on an SoC include a central processing unit (**CPU**), memory, input/output ports, storage devices
together with more sophisticated modules like audio digital interfaces, neural processing units (**NPU**) or graphical
processing units (**GPU**).

SoCs can be used in various applications most common are:
 - consumer electronics (TV sets, mobile phones, video game consoles)
 - industrial computers (medical imaging, etc)
 - automotive
 - home appliances

The leading architecture for SoCs is **ARM**. Worth mentioning here is that there are also x86-based SoCs platforms. Another thing
we need to keep an eye on is **RISC-V** an open standard instruction set architecture.

A simplified view of an **ARM** platform is shown in the image below:

.. image:: ../res/schematic.png
   :align: center

We will refer as a reference platform at NXP's `i.MX6UL <imx6ul>`_ platform, but in general all SoC's contain the following building blocks:

  - one or more CPU cores
  - a system bus
  - clock and reset module

    - PLL
    - OSC
    - reset controller

 - interrupt controller
 - timers
 - memory controller
 - peripheral controllers

   - `I2C <https://en.wikipedia.org/wiki/I%C2%B2C>`_
   - `SPI <https://en.wikipedia.org/wiki/Serial_Peripheral_Interface>`_
   - `GPIO <https://en.wikipedia.org/wiki/General-purpose_input/output>`_
   - `Ethernet <https://en.wikipedia.org/wiki/Network_interface_controller>`_ (for network)
   - `uSDHC <https://en.wikipedia.org/wiki/MultiMediaCard>`_ (for storage)
   - USB
   - `UART <https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter>`_
   - `I2S <https://en.wikipedia.org/wiki/I%C2%B2S>`_ (for sound)
   - eLCDIF (for LCD Panel)

Here is the complete block diagram for i.MX6UL platform:

.. image::  https://www.nxp.com/assets/images/en/block-diagrams/IMX6UL-BD.jpg
   :alt: IMX6UL-BD
   :width: 60 %
   :align: center

i.MX6UL Evaluation Kit board looks like this:

.. image:: https://www.compulab.com/wp-content/gallery/sbc-imx6ul/compulab_sbc-imx6ul_single-board-computer.jpg
   :alt: imx6ul-evk
   :width: 60 %
   :align: center

Other popular SoC boards:

        * `Broadcom Raspberry Pi <https://en.wikipedia.org/wiki/Raspberry_Pi>`_
        * `Texas Instruments Beagle board <https://en.wikipedia.org/wiki/BeagleBoard>`_
        * `Odroid Xu4 <https://wiki.odroid.com/odroid-xu4/odroid-xu4>`_
        * `Nvidia Jetson Nano <https://developer.nvidia.com/embedded/jetson-nano-developer-kit>`_

Board Support package
=====================

A board support package (**BSP**) is the minimal set of software packages that allow to demonstrate the capabilities of a certain hardware platform. This includes:

  - toolchain
  - bootloader
  - Linux kernel image, device tree files and drivers
  - root filesystem

Semiconductor manufacturers usually provide a **BSP** together with an evaluation board. BSP is typically bundled using `Yocto <https://www.yoctoproject.org/>`_

Toolchain
=========
Because our development machines are mostly x86-based we need a cross compiler that can produce executable
code for ARM platform.

We can build our own cross compiler from scratch using https://crosstool-ng.github.io/ or we can install one

.. code-block:: bash

  $ sudo apt-get install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf # for arm32
  $ sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu     # for arm64


Compiling the Linux kernel for ARM
----------------------------------

Compile the kernel for 32bit ARM boards:

.. code-block:: bash

  # select defconfig based on your platform
  $ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make imx_v6_v7_defconfig
  # compile the kernel
  $ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make -j8

Compile the kernel for 64bit ARM boards:

.. code-block:: bash

  # for 64bit ARM there is a single config for all supported boards
  $ ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make defconfig
  # compile the kernel
  $ ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- make -j8

Linux kernel image
==================

The kernel image binary is named ``vmlinux`` and it can be found in the root of the kernel tree. Compressed image used for booting can be found under:

- ``arch/arm/boot/Image``, for arm32
- ``arc/arm64/boot/Image``, for arm64

.. code-block:: bash

    $ file vmlinux
      vmlinux: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped

    $ file vmlinux
      vmlinux: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), statically linked, not stripped

Device tree
===========

Device tree (**DT**) is a tree structure used to describe the hardware devices in a system. Each node in the tree describes a device hence it is called **device node**. DT was introduced
to provide a way to discover non-discoverable hardware (e.g a device on an I2C bus). This information was previously stored inside the source code for the Linux kernel. This meant that
each time we needed to modify a node for a device the kernel needed to be recompiled. This no longer holds true as device tree and kernel image are separate binaries now.

Device trees are stored inside device tree sources (*.dts*) and compiled into device tree blobs (*.dtb*).

.. code-block:: bash

   # compile dtbs
   $ make dtbs

   # location for DT sources on arm32
   $ ls arch/arm/boot/dts/
     imx6ul-14x14-evk.dtb imx6ull-14x14-evk.dtb bcm2835-rpi-a-plus.dts

   # location for DT source on arm64
   $ ls arch/arm64/boot/dts/<vendor>
     imx8mm-evk.dts imx8mp-evk.dts


Exercises
=========

0. Intro
--------

Inspect the following locations in the Linux kernel code and identify platforms and vendors using
ARM architecture:
* 32-bit: ``arch/arm/boot/dts/``
* 64-bit: ``arch/arm64/boot/dts``

1. Boot
-------

Using `qemu` boot i.MX6UL platform.

.. code-block:: bash

   ../qemu/build/arm-softmmu/qemu-system-arm  -M mcimx6ul-evk -cpu
   cortex-a7 -m 512M -kernel arch/arm/boot/zImage -nographic  -dtb
   arch/arm/boot/dts/imx6ul-14x14-evk.dtb -append "root=/dev/mmcblk0 rw
   console=ttymxc0 loglevel=8 earlycon init=/bin/sh" -sd
   ../images/core-image-minimal-dev-qemuarm.ext4


2. Device tree

Study `imx6ul-14x14-evk.dts` file and identify the main components on the SoC.


.. _imx6ul: https://www.nxp.com/products/processors-and-microcontrollers/arm-processors/i-mx-applications-processors/i-mx-6-processors/i-mx-6ultralite-processor-low-power-secure-arm-cortex-a7-core:i.MX6UL
